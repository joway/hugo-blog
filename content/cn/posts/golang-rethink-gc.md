---
title: 重新思考 Go：内存管理
date: 2024-03-30
categories: ["Tech"]
draft: true
---

> 重新思考 Go 系列：这个系列希望结合工作中在 Go 编程与性能优化中遇到过的问题，探讨 Go 在语言哲学、底层实现和现实需求三者之间关系与矛盾。

---

Go 是一门带 GC 的语言，编程者既不需要思考创建的对象分配在栈或是堆上，亦不需要思考合适销毁堆上的对象。大部分现代语言尤其是广受流行的语言，已经很少会再要求编程者主动管理对象的释放，但是具体对于对象生命周期的管理做法上不同语言各有千秋，从运行时垃圾回收器自动扫描，再到 Rust 这类编译期所有权主动声明。

之前听说过一个不知真假的段子，说是导弹的软件代码就不需要释放资源，只需要内存大小足够软件运行到爆炸之前就足够。不管这个段子真假与否，但我却是遇到过不止一个非常核心的系统，因为各种查不清，修不完的内存泄漏问题，重度依靠着定时重启进程来解决内存泄漏问题。

内存管理本身就是一个非常硬件导向的事情，实际上大部分代码中都会存在众多的全局变量并不一定它的生命周期真的是全局性的，只是它内存占比太小我们不愿意花费脑力去管理，所以任由它一直存活。如果今天内存是以 PB 计算的，恐怕与其精心管理对象的生命周期，不如花更多时间研究关于进程无损重启的技术更符合现实需要。

Go 的内存分配器使用的是 tcmalloc 风格，垃圾回收使用的是并发

### 内存分配：不应该低估 make 的耗时

```go
costs := make([]time.Duration, 0, 10000000)
var buf []byte
for i := 0; i < cap(costs); i++ {
    begin := time.Now()
    buf = make([]byte, 1000)
    costs = append(costs, time.Since(begin))
}
```
