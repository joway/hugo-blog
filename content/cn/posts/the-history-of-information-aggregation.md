---
title: 从 SQL 角度看信息媒介的演变
date: 2021-06-17
draft: true
categories: ['Thought']
---

什么是信息？在 [《Looking for Information》](http://www.xxc.idv.tw/dokuwiki/study/case_d._o._2007_._looking_for_information) 一书中有如下定义：

> Information can be any difference you perceive, in your environment or within yourself. It is any aspect that you notice in the pattern of reality.

这个定义的精妙之处在于它是从信息传播链条的终点去理解的信息。

如果人是一台机器，我们的五感相当于一台负责**数据**采集的传感器，而大脑则负责从每时每刻的海量数据中归纳出有用的**信息**。总的来说这个大脑需要实现两类算法：一类是主动型算法，例如人过马路时需要有意识地识别是否有往来的车辆；另一类是被动算法，当你无意识地走在路上时，需要异步侦测是否有异常事件发生，一旦发生需要立刻打断你正在进行的行为，把你的意识切换到对异常事件的主动判断中去。无论是主动型算法还是被动型算法，它之所以能够工作，必须先对原始信息拥有一个初始状态的定义，然后才能从数据中甄别出异常点以发现新的信息。一个例子是当一个不懂农业的人和一个有经验的农民同时去观察一片受虫害困扰的麦田，大家获得的数据是一样的，但是获得的信息却是不同的，因为农民脑海中已经建立了一个健康的麦田应该是怎么样的认知。

在数据领域有一个叫 SQL (Structured Query Language) 的概念，通俗来说就是用一个结构化的语言描述你需要进行的数据检索和聚合行为。一个典型的 SQL 语句是这样的：`SELECT something FROM data WHERE condition GROUP BY something ORDER BY something`。即便你不了解技术，只要用英语将这句话读出来就能基本明白它的意思。使用这套语法结构可以描述出许多人类信息载体的基本逻辑。例如《论语》的 SQL 描述就是：`SELECT statement FROM conversation WHERE author = "孔子" GROUP BY topic ORDER BY time`，翻译过来就是从日常对话中，摘取孔子说的语句，并以主题分类，最后以对话发生时间排序，最终编撰成《论语》。如果你把 WHERE 语句内的条件换成孟子，那就是《孟子》的 SQL 描述。

一个信息要能够被人消费，实现信息真正的意义，必须依托于信息的载体。这个载体可以是一幅画，一本书，一部史诗，一份报纸，一个软件。

信息聚合的历史由来已久，几大文明最著名的作品多是出于信息聚合目的的产物。希罗多德的《历史》旨在聚合其在希腊游历时的道听途说，将原本以人类分散记忆为载体的故事通过书面语言的方式持久化地保存下来。司马迁的《史记》，犹太人的《塔纳赫》，基督教的《新约》，波斯人的《列王纪》都大抵如是。如果要给历史上的信息聚合产物分个类，主要有以下几个典型的类别：

- 基于时间/时代的聚合：代表作是《春秋》，《唐诗三百首》这类。
- 基于位置的聚合：将地区内作品聚合成册的，如《楚辞》。以及一些地方志如越国地区的《越绝》。
- 基于主题的聚合：该类型经常会被内嵌在其他聚合类型作为一个子聚合，例如《论语》里也会以不同主题分类。但还有一种是整本书就基于某一个特定的主题来编纂，例如《山海经》，《水经注》。
- 基于人的聚合：可以是基于某个作者的合集，例如 《东坡全集》。也可以是基于某个/多个人物事迹的合集，例如《论语》，《世说新语》。

对信息的聚合方式往往和时代所处于的科技水平强相关。人类的信息技术发展主要分为三个阶段：**造纸术的发明**，**印刷术的发明**，**计算机技术的发明**。

在造纸术发明前，信息生产成本与传播成本极大，导致信息聚合只能是出于国家或是宗教目的，往往用于建构一个国家的认同或是一个宗教的权威。在造纸术发明后，信息生产成本下降，但是在传播上还是基本依赖于手抄，这时期信息的存量显著增加，但很容易在传播中出现残本和佚本。而印刷术发明后，把传播成本也大幅下降，进而使得信息的受众大量增加，由此才可能出现以娱乐为目的的戏曲小说这类文学类型。在这漫长的信息科技演进过程中，我们可以以越来越丰富的纬度进行信息的分类聚合，从一国，一个时代的纬度，慢慢细化到一个作者，一个主题的纬度，直至到近代还发展出了报纸这类同时基于时间，位置，主题的聚合类型。

一直到现代的计算机技术的发明，信息的生产和传播成本以前所未有的速度极速下降，信息的数量和受众极速膨胀，这使得传统的信息聚合方法受到了挑战。在清朝你能够收集到的唐诗就极为有限，且能从唐朝流传到清朝的唐诗质量也已经经过了历史的筛选，所以很容易就能编成一本《唐诗三百首》。但在计算机时代，海量信息之间的质量差距巨大，并且受众数量的膨胀也导致了受众差异度的增加，传统的信息聚合方法面临着规模化和个性化的压力。

在互联网早期诞生的许多内容产品就在试图在传统的聚合方法上加上一定程度的个性化能力来满足新时代的信息需求，我们可以尝试用前面提到的 SQL 语法来描述早期互联网的一些典型内容产品：
- Google：SELECT * FROM data WHERE content CONTAINS keyword ORDER BY score
- Facebook：SELECT * FROM data WHERE creator IN (friends,...) ORDER BY time
- Twitter：SELECT * FROM data WHERE creator IN (folowing,...) ORDER BY time
- Reddit/百度贴吧：SELECT * FROM data GROUP BY topic ORDER BY score
- Yahoo News/网易新闻：SELECT * FROM data GROUP BY topic ORDER BY time

对 Google 来说，个性化依据是 keyword，对 Facebook 和 Twitter 来说是用户关系，对 Reddit ，百度贴吧和新闻网站来说是内容的主题。而排序的 score 在这个阶段并没有个性化的成分，完全依据内容的静态关系来计算出相应的分数。这类个性化的实现非常简单，对用户来说也是可控与可理解的。

在早期互联网的内容量级和受众差异度下，这种聚合方式姑且也能够被广泛接受。但随着计算机技术的进一步发展，尤其是移动计算设备的出现，任何一个人都可以通过图片，音频，视频的方式去生产内容，并以秒级的传播速度分发给地球上的任何一个人。今天一个江西农村小伙生产的信息被消费的人次，可能比司马迁这两千年积累下来的还要多。同样今天一个江西农村小伙所消费的信息量，也可能比司马迁这辈子收集的信息还要多。在这种数据规模下，用前面的聚合方法最终产生的结果依然

Google 的诞生就是在充当计算机时代的大脑，让我们能够以主动的方式从数据中快速获取到想要的信息。但是 Google 并不具备被动式获取信息的能力，如果你事先不知道纽约发生了大火，那么你在 Google 也并不能够知道纽约发生了大火。当然我们可以定期去纽约时报的网站上获取关于纽约的消息，但如果我还想要知道芝加哥的消息，我还得在我的每天例行查阅清单上在加上芝加哥报纸的网站。

为了解决人肉检阅各大门户网站的问题，人们发展出了 RSS 技术。RSS 技术抽象理解，可以认为是一种以 Pull 实现的 Push 技术。内容提供者通过分享一个固定的内容更新链接，软件客户端实现定时拉取判断是否有新内容更新，然后同步到本地客户端。从技术工程师角度来说，这是一种 Pull 的模式，但从普通消费者角度理解，只会认为是网站 Push 了内容给我。RSS 技术能够实现用户只需要在一个消息流中信步，就能获得到所有之前订阅了的信源的更新。甚至通过操作系统的配合，可以进一步做到在你处理着其他事情时，在信源更新时弹出消息提醒，到了这一步，已经很接近前面提到的人走在马路上时大脑的处理模型。

但 RSS 技术在根本上只是一种聚合的聚合，其背后的订阅源主要还是以门户网站与个人博客为主，这两类信源本身就是基于时间/位置/主题/作者这套聚合模型的产物。一个 RSS 流的信息质量完全取决于信源的信息质量，而信源往往是由一群受过良好教育的知识分子或是自己创作内容，或是编纂其他知识分子创作的内容，而你选择订阅了这个信源，意味着你已经通过主观意识赋予了这个信源质量与兴趣上的信任。


